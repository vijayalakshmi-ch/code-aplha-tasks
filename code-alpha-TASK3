Frontend: HTML/CSS/JavaScript
a) index.html (Game Interface and Player Login)
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Multiplayer Online Game</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <h1>Multiplayer Game</h1>

  <div id="login-form">
    <h2>Login</h2>
    <input type="text" id="username" placeholder="Username" required>
    <button onclick="login()">Login</button>
  </div>

  <div id="game-area" style="display:none;">
    <h2>Game Area</h2>
    <div id="game-status">Waiting for opponent...</div>
    <div id="game-board"></div>
  </div>

  <script src="game.js"></script>
</body>
</html>
b) game.js (Game Logic & WebSocket Communication)
let socket;
let playerId;

function login() {
  const username = document.getElementById('username').value;
  
  // Simulate player authentication (frontend-only, real authentication on the server)
  if (username) {
    playerId = username; // In real app, this would be generated by server on signup/login
    
    document.getElementById('login-form').style.display = 'none';
    document.getElementById('game-area').style.display = 'block';
    
    // Initialize WebSocket connection to the server
    socket = new WebSocket('ws://localhost:3000');
    
    // Handle incoming messages
    socket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      
      if (data.type === 'game-start') {
        document.getElementById('game-status').innerText = `Playing against ${data.opponent}`;
        // Initialize game logic here
      } else if (data.type === 'game-update') {
        // Handle real-time game updates
        updateGameBoard(data.state);
      }
    };
    
    // Send player details to the server
    socket.onopen = () => {
      socket.send(JSON.stringify({ type: 'login', playerId }));
    };
  }
}

function updateGameBoard(state) {
  const board = document.getElementById('game-board');
  board.innerHTML = ''; // Clear the board for fresh updates
  // Render the new game state here, e.g., for a tic-tac-toe game or any multiplayer game logic
}
Backend: Node.js with WebSockets
a) Install Dependencies
mkdir backend
cd backend
npm init -y
npm install express mongoose bcryptjs jsonwebtoken ws
b) app.js (Main Backend Server)
const express = require('express');
const mongoose = require('mongoose');
const WebSocket = require('ws');
const jwt = require('jsonwebtoken');
const Player = require('./models/Player');
const gameController = require('./controllers/gameController');
const matchmaking = require('./utils/matchmaking');

const app = express();
const PORT = 3000;
const wss = new WebSocket.Server({ port: 8080 });

// Middleware
app.use(express.json());
app.use('/api/auth', require('./routes/authRoutes'));

// MongoDB connection
mongoose.connect('mongodb://localhost/multiplayer-game', { useNewUrlParser: true, useUnifiedTopology: true })
  .then(() => console.log('MongoDB connected'))
  .catch(err => console.log(err));

// WebSocket server for real-time communication
let waitingPlayer = null;

wss.on('connection', (ws) => {
  ws.on('message', (message) => {
    const data = JSON.parse(message);

    if (data.type === 'login') {
      const player = { id: data.playerId, ws };

      if (waitingPlayer) {
        // Match players
        const gameId = gameController.startGame(waitingPlayer, player);
        ws.send(JSON.stringify({ type: 'game-start', opponent: waitingPlayer.id, gameId }));
        waitingPlayer.ws.send(JSON.stringify({ type: 'game-start', opponent: player.id, gameId }));
        waitingPlayer = null;
      } else {
        waitingPlayer = player;
      }
    } else if (data.type === 'game-move') {
      gameController.handleMove(data);
    }
  });

  ws.on('close', () => {
    console.log('Player disconnected');
    if (waitingPlayer && waitingPlayer.ws === ws) {
      waitingPlayer = null;
    }
  });
});

app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});
c) models/Player.js (Player Schema for MongoDB)
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const PlayerSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  wins: { type: Number, default: 0 },
  losses: { type: Number, default: 0 },
});

// Hash password before saving the player
PlayerSchema.pre('save', async function (next) {
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

module.exports = mongoose.model('Player', PlayerSchema);
d) routes/authRoutes.js (Authentication Routes)
const express = require('express');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const Player = require('../models/Player');
const router = express.Router();

// Signup
router.post('/signup', async (req, res) => {
  const { username, password } = req.body;

  try {
    let player = await Player.findOne({ username });
    if (player) {
      return res.status(400).json({ msg: 'Player already exists' });
    }

    player = new Player({ username, password });
    await player.save();

    const token = jwt.sign({ id: player.id }, 'secret', { expiresIn: 3600 });
    res.json({ token });
  } catch (err) {
    res.status(500).send('Server error');
  }
});

// Login
router.post('/login', async (req, res) => {
  const { username, password } = req.body;

  try {
    const player = await Player.findOne({ username });
    if (!player) {
      return res.status(400).json({ msg: 'Invalid credentials' });
    }

    const isMatch = await bcrypt.compare(password, player.password);
    if (!isMatch) {
      return res.status(400).json({ msg: 'Invalid credentials' });
    }

    const token = jwt.sign({ id: player.id }, 'secret', { expiresIn: 3600 });
    res.json({ token });
  } catch (err) {
    res.status(500).send('Server error');
  }
});

module.exports = router;
e) controllers/gameController.js (Game Logic Controller)
let games = {}; // Store games by ID

// Start a new game between two players
function startGame(player1, player2) {
  const gameId = `${player1.id}-${player2.id}`;
  games[gameId] = { player1, player2, state: 'ongoing' };
  return gameId;
}

// Handle game move (e.g., update game state)
function handleMove(data) {
  const { gameId, move } = data;
  const game = games[gameId];

 
